<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Percaloid Engine v2 - 3 Layer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #0a0e14;
            color: #e0e0e0;
            overflow-x: hidden;
            min-height: 100vh;
            touch-action: manipulation;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding: 8px;
            gap: 8px;
            max-width: 1800px;
            margin: 0 auto;
        }

        /* ============= LAYER SELECTOR ============= */
        .layer-selector {
            display: flex;
            gap: 8px;
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .layer-tab {
            flex: 1;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(109, 217, 219, 0.3);
            border-radius: 4px;
            color: #6dd9db;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }

        .layer-tab:active {
            transform: scale(0.95);
        }

        .layer-tab.active {
            background: #6dd9db;
            color: #0a0e14;
            border-color: #6dd9db;
            box-shadow: 0 0 20px rgba(109, 217, 219, 0.5);
        }

        .layer-tab.layer1 { border-color: rgba(109, 217, 219, 0.5); }
        .layer-tab.layer2 { border-color: rgba(255, 159, 64, 0.5); }
        .layer-tab.layer3 { border-color: rgba(138, 80, 255, 0.5); }

        .layer-tab.layer1.active { background: #6dd9db; }
        .layer-tab.layer2.active { background: #ff9f40; }
        .layer-tab.layer3.active { background: #8a50ff; }

        /* ============= TOP BAR ============= */
        .top-bar {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 10px 12px;
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            flex-wrap: wrap;
        }

        .transport {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            min-width: 48px;
            border-radius: 50%;
            background: rgba(109, 217, 219, 0.15);
            border: 3px solid rgba(109, 217, 219, 0.4);
            color: #6dd9db;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        .play-btn.playing {
            background: #6dd9db;
            color: #0a0e14;
            border-color: #6dd9db;
            box-shadow: 0 0 20px rgba(109, 217, 219, 0.5);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 70px;
        }

        .control-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #6dd9db;
            font-weight: 600;
        }

        .select-input, .number-input {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(109, 217, 219, 0.4);
            border-radius: 3px;
            padding: 6px 8px;
            color: #e0e0e0;
            font-size: 11px;
            font-family: inherit;
            cursor: pointer;
            outline: none;
            transition: all 0.2s;
        }

        .number-input {
            width: 60px;
        }

        .btn {
            background: rgba(109, 217, 219, 0.12);
            border: 1px solid rgba(109, 217, 219, 0.3);
            border-radius: 3px;
            padding: 8px 12px;
            color: #6dd9db;
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            outline: none;
            font-family: inherit;
            min-height: 36px;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn.active {
            background: #6dd9db;
            color: #0a0e14;
            border-color: #6dd9db;
        }

        /* ============= MACROS PANEL ============= */
        .macros-panel {
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .macros-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 8px;
        }

        .macro-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .macro-label {
            font-size: 8px;
            font-weight: 600;
            color: #6dd9db;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .knob-container {
            position: relative;
            width: 50px;
            height: 50px;
        }

        .knob {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, rgba(109, 217, 219, 0.15), rgba(0, 0, 0, 0.8));
            border: 3px solid rgba(109, 217, 219, 0.3);
            position: relative;
            cursor: pointer;
            touch-action: none;
            transition: border-color 0.2s;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 16px;
            background: linear-gradient(180deg, #6dd9db, rgba(109, 217, 219, 0.6));
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            pointer-events: none;
            box-shadow: 0 0 4px rgba(109, 217, 219, 0.5);
        }

        .knob-value {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            color: #808080;
            font-weight: 600;
        }

        /* ============= SEQUENCER ============= */
        .sequencer-section {
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .sequencer-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            margin-top: 8px;
        }

        .step-container {
            display: flex;
            flex-direction: column;
            gap: 3px;
            align-items: center;
        }

        .step {
            width: 100%;
            aspect-ratio: 1;
            min-width: 36px;
            min-height: 36px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(109, 217, 219, 0.25);
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            transition: all 0.12s;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #6dd9db;
            touch-action: manipulation;
        }

        .step:active {
            transform: scale(0.9);
        }

        .step.active {
            background: linear-gradient(135deg, #6dd9db, #5ac5c7);
            border-color: #6dd9db;
            box-shadow: 0 0 12px rgba(109, 217, 219, 0.6);
            color: #0a0e14;
        }

        .step.current {
            border-color: #ff9f40;
            box-shadow: 0 0 12px rgba(255, 159, 64, 0.5);
            animation: pulse 0.15s ease-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        .step.accent::before {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            width: 6px;
            height: 6px;
            background: #ff9f40;
            border-radius: 50%;
            box-shadow: 0 0 4px rgba(255, 159, 64, 0.6);
        }

        .note-slider {
            width: 100%;
            height: 60px;
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 3px;
            outline: none;
            cursor: ns-resize;
            opacity: 0.7;
        }

        .note-label {
            font-size: 7px;
            color: #6dd9db;
            text-align: center;
            height: 14px;
            line-height: 14px;
        }

        /* ============= VOICE PANEL ============= */
        .voice-panel {
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .voice-controls {
            display: grid;
            gap: 10px;
            margin-top: 8px;
        }

        .voice-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
            margin-top: 4px;
        }

        .mode-btn {
            padding: 8px 4px;
            font-size: 8px;
        }

        .slider-container {
            position: relative;
            height: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid rgba(109, 217, 219, 0.2);
            cursor: pointer;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, rgba(109, 217, 219, 0.7), #6dd9db);
            border-radius: 6px;
            transition: width 0.1s;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(109, 217, 219, 0.4);
        }

        .slider {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* ============= SCENE CONTROLS ============= */
        .scene-controls {
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .scene-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .scene-btns {
            display: flex;
            gap: 6px;
        }

        .scene-btn {
            flex: 1;
            padding: 10px 8px;
            min-width: 70px;
        }

        .morph-control {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .morph-label {
            font-size: 9px;
            color: #6dd9db;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 12px;
        }

        /* ============= FX FOOTER ============= */
        .fx-footer {
            background: rgba(20, 25, 35, 0.8);
            border-radius: 6px;
            border: 1px solid rgba(109, 217, 219, 0.2);
            padding: 12px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .fx-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .fx-label {
            font-size: 8px;
            font-weight: 600;
            color: #6dd9db;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        h3 {
            text-align: center;
            color: #6dd9db;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .hint {
            text-align: center;
            color: #606060;
            font-size: 8px;
            padding-top: 6px;
            letter-spacing: 0.3px;
        }

        .divider {
            height: 1px;
            background: rgba(109, 217, 219, 0.2);
            margin: 8px 0;
        }

        /* ============= DESKTOP LAYOUT ============= */
        @media (min-width: 768px) {
            .container {
                padding: 12px;
                gap: 12px;
            }

            .top-bar {
                padding: 12px 16px;
                gap: 16px;
            }

            .play-btn {
                width: 52px;
                height: 52px;
            }

            .control-group {
                min-width: 80px;
            }

            .control-label {
                font-size: 9px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 10px;
            }

            .macros-panel {
                padding: 16px;
            }

            .macros-grid {
                grid-template-columns: repeat(6, 1fr);
                gap: 16px;
            }

            .knob-container {
                width: 60px;
                height: 60px;
            }

            .knob::after {
                width: 4px;
                height: 20px;
                top: 8px;
            }

            .macro-label {
                font-size: 9px;
            }

            .sequencer-section {
                padding: 16px;
            }

            .sequencer-grid {
                grid-template-columns: repeat(16, 1fr);
                gap: 6px;
            }

            .step {
                min-width: 40px;
                min-height: 40px;
                font-size: 9px;
            }

            .note-slider {
                height: 80px;
            }

            .note-label {
                font-size: 8px;
            }

            .voice-panel {
                padding: 16px;
            }

            .voice-controls {
                gap: 12px;
            }

            .fx-footer {
                grid-template-columns: repeat(4, 1fr);
                gap: 16px;
                padding: 12px 16px;
            }

            .fx-label {
                font-size: 9px;
            }

            h3 {
                font-size: 11px;
            }

            .hint {
                font-size: 9px;
            }
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(109, 217, 219, 0.3);
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- LAYER SELECTOR -->
        <div class="layer-selector">
            <button class="layer-tab layer1 active" data-layer="0">Layer 1</button>
            <button class="layer-tab layer2" data-layer="1">Layer 2</button>
            <button class="layer-tab layer3" data-layer="2">Layer 3</button>
        </div>

        <!-- TOP BAR -->
        <div class="top-bar">
            <div class="transport">
                <button class="play-btn" id="playBtn">▶</button>
            </div>

            <div class="control-group">
                <label class="control-label">Tempo</label>
                <input type="number" class="number-input" id="tempoInput" value="120" min="60" max="200">
            </div>

            <div class="control-group">
                <label class="control-label">Length</label>
                <select class="select-input" id="lengthSelect">
                    <option value="4">4</option>
                    <option value="8">8</option>
                    <option value="16" selected>16</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Clock</label>
                <select class="select-input" id="clockDivSelect">
                    <option value="1/64">1/64</option>
                    <option value="1/32">1/32</option>
                    <option value="1/16">1/16</option>
                    <option value="1/8">1/8</option>
                    <option value="1/4">1/4</option>
                    <option value="1/2">1/2</option>
                    <option value="1/1" selected>1 Bar</option>
                    <option value="2/1">2 Bars</option>
                    <option value="4/1">4 Bars</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Root</label>
                <select class="select-input" id="rootSelect">
                    <option value="C">C</option>
                    <option value="C#">C#</option>
                    <option value="D" selected>D</option>
                    <option value="D#">D#</option>
                    <option value="E">E</option>
                    <option value="F">F</option>
                    <option value="F#">F#</option>
                    <option value="G">G</option>
                    <option value="G#">G#</option>
                    <option value="A">A</option>
                    <option value="A#">A#</option>
                    <option value="B">B</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Scale</label>
                <select class="select-input" id="scaleSelect">
                    <option value="major">Major</option>
                    <option value="minor" selected>Minor</option>
                    <option value="dorian">Dorian</option>
                    <option value="phrygian">Phrygian</option>
                    <option value="lydian">Lydian</option>
                    <option value="mixolydian">Mixolydian</option>
                    <option value="locrian">Locrian</option>
                    <option value="pentatonic">Pentatonic</option>
                    <option value="harmonic">Harmonic</option>
                    <option value="melodic">Melodic</option>
                </select>
            </div>

            <div class="control-group">
                <label class="control-label">Octave</label>
                <select class="select-input" id="octaveSelect">
                    <option value="1">1-2</option>
                    <option value="2">2-3</option>
                    <option value="3" selected>3-4</option>
                    <option value="4">4-5</option>
                    <option value="5">5-6</option>
                </select>
            </div>

            <button class="btn" id="evolveBtn">Evolve</button>
            <button class="btn" id="randomBtn">Random</button>
            <button class="btn" id="testToneBtn">Test</button>
        </div>

        <!-- MACROS PANEL -->
        <div class="macros-panel">
            <h3>Macros</h3>
            <div class="macros-grid" id="macrosGrid"></div>
        </div>

        <!-- SEQUENCER -->
        <div class="sequencer-section">
            <h3>Sequencer</h3>
            <div class="sequencer-grid" id="sequencerGrid"></div>
            <div class="hint">
                Tap step • Long-press for accent • Slider for note
            </div>
        </div>

        <!-- VOICE PANEL -->
        <div class="voice-panel">
            <h3>Voice</h3>
            
            <div class="voice-controls">
                <div class="voice-control">
                    <label class="control-label">Mode</label>
                    <div class="mode-selector" id="modeSelector"></div>
                </div>

                <div class="voice-control">
                    <label class="control-label">Drive</label>
                    <div class="slider-container">
                        <div class="slider-fill" id="driveFill"></div>
                        <input type="range" class="slider" id="driveSlider" min="0" max="100" value="30">
                    </div>
                </div>

                <div class="voice-control">
                    <label class="control-label">Tune</label>
                    <div class="slider-container">
                        <div class="slider-fill" id="tuneFill"></div>
                        <input type="range" class="slider" id="tuneSlider" min="0" max="100" value="50">
                    </div>
                </div>

                <div class="voice-control">
                    <label class="control-label">Attack</label>
                    <div class="slider-container">
                        <div class="slider-fill" id="attackFill"></div>
                        <input type="range" class="slider" id="attackSlider" min="0" max="100" value="10">
                    </div>
                </div>

                <div class="divider"></div>

                <div class="voice-control">
                    <label class="control-label">FM Ratio 1</label>
                    <div class="slider-container">
                        <div class="slider-fill" id="ratio1Fill"></div>
                        <input type="range" class="slider" id="ratio1Slider" min="0" max="100" value="50">
                    </div>
                </div>

                <div class="voice-control">
                    <label class="control-label">FM Ratio 2</label>
                    <div class="slider-container">
                        <div class="slider-fill" id="ratio2Fill"></div>
                        <input type="range" class="slider" id="ratio2Slider" min="0" max="100" value="60">
                    </div>
                </div>

                <div class="voice-control">
                    <label class="control-label">FM Index</label>
                    <div class="slider-container">
                        <div class="slider-fill" id="fmIndexFill"></div>
                        <input type="range" class="slider" id="fmIndexSlider" min="0" max="100" value="40">
                    </div>
                </div>
            </div>
        </div>

        <!-- SCENE CONTROLS -->
        <div class="scene-controls">
            <div class="scene-row">
                <div class="scene-btns">
                    <button class="btn scene-btn active" id="sceneABtn">Scene A</button>
                    <button class="btn scene-btn" id="sceneBBtn">Scene B</button>
                </div>
                <button class="btn" id="saveSceneBtn">Save</button>
            </div>
            
            <div class="morph-control">
                <span class="morph-label">A</span>
                <div class="slider-container" style="flex: 1;">
                    <div class="slider-fill" id="morphFill"></div>
                    <input type="range" class="slider" id="morphSlider" min="0" max="100" value="0">
                </div>
                <span class="morph-label">B</span>
            </div>
        </div>

        <!-- FX FOOTER -->
        <div class="fx-footer">
            <div class="fx-control">
                <label class="fx-label">Delay Mix</label>
                <div class="slider-container">
                    <div class="slider-fill" id="delayMixFill"></div>
                    <input type="range" class="slider" id="delayMixSlider" min="0" max="100" value="25">
                </div>
            </div>

            <div class="fx-control">
                <label class="fx-label">Delay Time</label>
                <div class="slider-container">
                    <div class="slider-fill" id="delayTimeFill"></div>
                    <input type="range" class="slider" id="delayTimeSlider" min="0" max="100" value="35">
                </div>
            </div>

            <div class="fx-control">
                <label class="fx-label">Delay FB</label>
                <div class="slider-container">
                    <div class="slider-fill" id="delayFbFill"></div>
                    <input type="range" class="slider" id="delayFbSlider" min="0" max="100" value="40">
                </div>
            </div>

            <div class="fx-control">
                <label class="fx-label">Reverb Mix</label>
                <div class="slider-container">
                    <div class="slider-fill" id="reverbFill"></div>
                    <input type="range" class="slider" id="reverbSlider" min="0" max="100" value="18">
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function expMap(min, max, t) {
            return min * Math.pow(max / min, t);
        }

        function smoothstep(min, max, t) {
            const x = Math.max(0, Math.min(1, (t - min) / (max - min)));
            return x * x * (3 - 2 * x);
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function gauss(mean, stdDev) {
            const u1 = Math.random();
            const u2 = Math.random();
            const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mean + stdDev * z0;
        }

        // ============================================================================
        // SCALE DEFINITIONS
        // ============================================================================
        
        const scales = {
            major: [0, 2, 4, 5, 7, 9, 11],
            minor: [0, 2, 3, 5, 7, 8, 10],
            dorian: [0, 2, 3, 5, 7, 9, 10],
            phrygian: [0, 1, 3, 5, 7, 8, 10],
            lydian: [0, 2, 4, 6, 7, 9, 11],
            mixolydian: [0, 2, 4, 5, 7, 9, 10],
            locrian: [0, 1, 3, 5, 6, 8, 10],
            pentatonic: [0, 2, 4, 7, 9],
            harmonic: [0, 2, 3, 5, 7, 8, 11],
            melodic: [0, 2, 3, 5, 7, 9, 11]
        };

        const noteFreqs = {
            'C': 32.70, 'C#': 34.65, 'D': 36.71, 'D#': 38.89, 'E': 41.20,
            'F': 43.65, 'F#': 46.25, 'G': 49.00, 'G#': 51.91, 'A': 55.00, 'A#': 58.27, 'B': 61.74
        };

        const macroDefinitions = [
            { key: 'shape', label: 'Shape', default: 0.35 },
            { key: 'density', label: 'Density', default: 0.5 },
            { key: 'entropy', label: 'Entropy', default: 0.15 },
            { key: 'contrast', label: 'Contrast', default: 0.60 },
            { key: 'melodicize', label: 'Melodic', default: 0.10 },
            { key: 'metallic', label: 'Metal', default: 0.30 },
            { key: 'decay', label: 'Decay', default: 0.40 },
            { key: 'spread', label: 'Spread', default: 0.25 },
            { key: 'brightness', label: 'Bright', default: 0.50 },
            { key: 'harmonics', label: 'Harmonic', default: 0.30 },
            { key: 'tension', label: 'Tension', default: 0.40 },
            { key: 'air', label: 'Air', default: 0.20 }
        ];

        // ============================================================================
        // STATE MANAGEMENT - 3 LAYERS
        // ============================================================================
        
        const globalState = {
            tempo: 120,
            playing: false,
            root: 'D',
            scale: 'minor',
            currentLayer: 0,
            layers: []
        };

        // Initialize 3 layers
        function createLayerState(layerIndex) {
            const defaultModes = ['drum', 'bass', 'lead'];
            const layer = {
                mode: defaultModes[layerIndex],
                octaveRange: 3,
                currentScene: 'A',
                morphAmount: 0,
                length: 16,
                clockDivision: '1/1',
                currentStep: 0,
                macros: {},
                voice: {
                    drive: 0.3,
                    tune: 0.5,
                    ratio1: 0.5,
                    ratio2: 0.6,
                    fmIndex: 0.4,
                    attack: 0.1
                },
                fx: {
                    delayMix: 0.25,
                    delayTime: 0.35,
                    delayFb: 0.40,
                    reverb: 0.18
                },
                pattern: Array(16).fill(null).map(() => ({ 
                    t: 0, 
                    acc: 0, 
                    note: 0
                })),
                scenes: {
                    A: null,
                    B: null
                }
            };

            // Initialize macros
            macroDefinitions.forEach(macro => {
                layer.macros[macro.key] = macro.default;
            });

            // All layers start with empty patterns - user programs from scratch

            return layer;
        }

        globalState.layers = [
            createLayerState(0),
            createLayerState(1),
            createLayerState(2)
        ];

        function getCurrentLayer() {
            return globalState.layers[globalState.currentLayer];
        }

        // ============================================================================
        // AUDIO ENGINE - 3 SEPARATE CHAINS
        // ============================================================================
        
        let loops = [], initialized = false;
        const audioEngines = [];

        // Convert clock division string to Tone.js time notation
        function getLoopInterval(clockDiv, patternLength) {
            // Clock division defines how long the entire pattern takes
            // e.g., "1/1" = pattern completes in 1 bar
            //       "1/2" = pattern completes in 1/2 bar
            //       "2/1" = pattern completes in 2 bars
            
            // Map clock division to number of bars
            const barsMap = {
                '1/64': 1/64,
                '1/32': 1/32,
                '1/16': 1/16,
                '1/8': 1/8,
                '1/4': 1/4,
                '1/2': 1/2,
                '1/1': 1,
                '2/1': 2,
                '4/1': 4
            };
            
            const totalBars = barsMap[clockDiv];
            const barsPerStep = totalBars / patternLength;
            
            // Convert bars per step to Tone.js notation
            // 1 bar = "1m", 1/2 bar = "2n", 1/4 bar = "4n", etc.
            const fraction = 1 / barsPerStep;
            
            if (fraction <= 1) {
                // Multiple bars per step
                const bars = Math.round(1 / fraction);
                return `${bars}m`;
            } else {
                // Fraction of a bar per step
                const note = Math.round(fraction);
                return `${note}n`;
            }
        }

        function getMacroMappedParams(layerState) {
            const m = layerState.macros;
            const v = layerState.voice;
            
            const modeShapeBias = {
                drum: 0.25,
                bass: 0.45,
                lead: 0.65,
                pad: 0.85
            };
            
            const effectiveShape = lerp(m.shape, modeShapeBias[layerState.mode], 0.3);
            
            const noiseMix = Math.pow(1 - smoothstep(0.05, 0.75, effectiveShape), 2.0);
            const carrierGain = smoothstep(0.05, 0.95, effectiveShape);
            
            const baseRatio1 = lerp(0.25, 8.0, v.ratio1);
            const baseRatio2 = lerp(0.5, 12.0, v.ratio2);
            
            const ratio1 = lerp(baseRatio1, 1.618 * (1 + m.metallic * 2), m.metallic * 0.8);
            const ratio2 = lerp(baseRatio2, 2.414 * (1 + m.metallic * 2.5), m.metallic * 0.8);
            
            const harmonicRatio1Mod = 1 + (m.harmonics * 3.0);
            const harmonicRatio2Mod = 1 + (m.harmonics * 4.0);
            
            const finalRatio1 = ratio1 * harmonicRatio1Mod;
            const finalRatio2 = ratio2 * harmonicRatio2Mod;
            
            const baseIndex = lerp(15, 0.3, effectiveShape);
            const modIndex = baseIndex * (1 + m.metallic * 5) * v.fmIndex * 4;
            
            const tensionAttackMult = lerp(0.5, 3.0, m.tension);
            const tensionTransient = lerp(0.5, 4.0, m.tension);
            
            // Attack controlled by user parameter with tension modulation
            const envAttack = lerp(0.001, 0.2, v.attack) * tensionAttackMult;
            const envDecay = expMap(0.005, 2.0, effectiveShape * (1 + m.decay * 1.5));
            const envSustain = smoothstep(0.3, 1, effectiveShape * m.melodicize) * 0.7;
            const envRelease = envDecay * lerp(0.3, 2.0, m.decay);
            
            const brightnessBoost = lerp(1.0, 8.0, m.brightness);
            const filterCutoff = expMap(150, 18000, effectiveShape * brightnessBoost);
            const filterQ = lerp(0.3, 35, m.metallic * m.brightness) * (1 + m.contrast * 2);
            
            const combMix = m.metallic * 0.9 * (1 - effectiveShape * 0.2);
            const combFeedback = lerp(0.5, 0.97, m.metallic);
            
            const driveAmount = lerp(0.1, 15, m.contrast * v.drive);
            const transientGain = lerp(0.2, 4.0, m.contrast * tensionTransient);
            
            const airMix = m.air * 0.8;
            const airCutoff = lerp(4000, 12000, m.air);
            
            const pitchJitter = m.entropy * 80;
            const timingJitter = m.entropy * 0.05;
            
            return {
                noiseMix,
                carrierGain,
                ratio1: finalRatio1,
                ratio2: finalRatio2,
                modIndex,
                envAttack,
                envDecay,
                envSustain,
                envRelease,
                filterCutoff,
                filterQ,
                combMix,
                combFeedback,
                driveAmount,
                transientGain,
                pitchJitter,
                timingJitter,
                airMix,
                airCutoff,
                brightnessBoost,
                tensionTransient
            };
        }

        async function initAudio() {
            if (initialized) return;
            
            await Tone.start();
            console.log('🎵 Percaloid Engine v2 - 3 Layer - Audio Started');
            
            // Create 3 independent audio engines
            for (let i = 0; i < 3; i++) {
                const filter = new Tone.Filter({
                    type: 'lowpass',
                    frequency: 3000,
                    Q: 2
                });
                
                const distortion = new Tone.Distortion({
                    distortion: 0.3,
                    wet: 0.4
                });
                
                const reverb = new Tone.Reverb({
                    decay: 2.5,
                    wet: 0.18
                });
                
                const delay = new Tone.FeedbackDelay({
                    delayTime: '8n',
                    feedback: 0.4,
                    wet: 0.25
                });
                
                const limiter = new Tone.Limiter(-3);
                const masterGain = new Tone.Gain(0.5); // Lower gain per layer to prevent clipping
                
                distortion.connect(filter);
                filter.connect(masterGain);
                masterGain.connect(limiter);
                limiter.toDestination();
                masterGain.connect(delay);
                masterGain.connect(reverb);
                delay.connect(limiter);
                reverb.connect(limiter);
                
                const fmSynth = new Tone.FMSynth({
                    volume: 0,
                    harmonicity: 1.5,
                    modulationIndex: 3,
                    envelope: {
                        attack: 0.001,
                        decay: 0.1,
                        sustain: 0.0,
                        release: 0.1
                    },
                    modulation: {
                        type: 'sine'
                    },
                    modulationEnvelope: {
                        attack: 0.001,
                        decay: 0.2,
                        sustain: 0,
                        release: 0.1
                    }
                }).connect(distortion);
                
                const fmSynth2 = new Tone.FMSynth({
                    volume: -6,
                    harmonicity: 2.0,
                    modulationIndex: 2,
                    envelope: {
                        attack: 0.001,
                        decay: 0.08,
                        sustain: 0.0,
                        release: 0.08
                    },
                    modulation: {
                        type: 'sine'
                    },
                    modulationEnvelope: {
                        attack: 0.001,
                        decay: 0.15,
                        sustain: 0,
                        release: 0.08
                    }
                }).connect(distortion);
                
                const noise = new Tone.Noise('pink').start();
                const noiseEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.001,
                    decay: 0.03,
                    sustain: 0,
                    release: 0.01
                }).connect(distortion);
                noise.connect(noiseEnv);
                
                const airNoise = new Tone.Noise('white').start();
                const airFilter = new Tone.Filter({
                    type: 'highpass',
                    frequency: 4000,
                    Q: 1
                });
                const airEnv = new Tone.AmplitudeEnvelope({
                    attack: 0.002,
                    decay: 0.05,
                    sustain: 0,
                    release: 0.02
                }).connect(distortion);
                airNoise.connect(airFilter);
                airFilter.connect(airEnv);
                
                audioEngines.push({
                    fmSynth,
                    fmSynth2,
                    masterGain,
                    noiseEnv,
                    noise,
                    airNoise,
                    airFilter,
                    airEnv,
                    filter,
                    distortion,
                    delay,
                    reverb,
                    limiter
                });
            }
            
            Tone.Transport.bpm.value = globalState.tempo;
            
            // Create 3 independent loops, one per layer
            globalState.layers.forEach((layer, layerIndex) => {
                const layerLoop = new Tone.Loop((time) => {
                    try {
                        const step = layer.pattern[layer.currentStep];
                        const currentMacros = getCurrentMacros(layer);
                        
                        let shouldTrigger = false;
                        
                        // Density at 0.5 (12 o'clock) = baseline
                        // Below 0.5: thins out programmed steps
                        // Above 0.5: adds generative fills to unprogrammed steps
                        
                        if (step.t) {
                            // Programmed step
                            if (currentMacros.density >= 0.5) {
                                // Above 50%: always fire programmed steps
                                shouldTrigger = true;
                            } else {
                                // Below 50%: probability scales from 0% at density=0 to 100% at density=0.5
                                const probability = currentMacros.density / 0.5;
                                shouldTrigger = Math.random() < probability;
                            }
                        } else {
                            // Unprogrammed step
                            if (currentMacros.density > 0.5) {
                                // Above 50%: chance of generative fill
                                // Scales from 0% at density=0.5 to 100% at density=1.0
                                const fillProbability = (currentMacros.density - 0.5) / 0.5;
                                shouldTrigger = Math.random() < fillProbability;
                            }
                        }
                        
                        if (shouldTrigger) {
                            triggerNote(layerIndex, step, currentMacros, layer, time);
                        }
                        
                        // Only update UI for currently visible layer
                        if (layerIndex === globalState.currentLayer) {
                            requestAnimationFrame(updateUI);
                        }
                        
                        layer.currentStep = (layer.currentStep + 1) % layer.length;
                    } catch (error) {
                        console.error(`Layer ${layerIndex} loop error:`, error);
                    }
                }, getLoopInterval(layer.clockDivision, layer.length));
                
                loops.push(layerLoop);
            });
            
            initialized = true;
        }

        function triggerNote(layerIndex, step, currentMacros, layerState, time) {
            const params = getMacroMappedParams(layerState);
            
            const rootFreq = noteFreqs[globalState.root];
            const scaleNotes = scales[globalState.scale];
            const octave = layerState.octaveRange;
            
            const scaleDegree = Math.abs(step.note) % scaleNotes.length;
            const octaveOffset = Math.floor(step.note / scaleNotes.length);
            const semitone = scaleNotes[scaleDegree];
            
            let freq = rootFreq * Math.pow(2, (semitone + (octave + octaveOffset) * 12) / 12);
            
            const shapePitchBias = lerp(0.7, 1.0, currentMacros.shape);
            freq *= shapePitchBias;
            
            const jitter = gauss(0, params.pitchJitter);
            freq *= Math.pow(2, jitter / 1200);
            
            freq *= Math.pow(2, (layerState.voice.tune - 0.5) * 24 / 12);
            
            const spreadAmount = currentMacros.spread;
            const stepParity = globalState.currentStep % 2;
            const spreadCents = stepParity ? spreadAmount * 20 : -spreadAmount * 20;
            freq *= Math.pow(2, spreadCents / 1200);
            
            const vel = step.acc ? 1.0 : 0.7;
            
            const engine = audioEngines[layerIndex];
            
            if (!engine) return;
            
            const finalRatio1 = params.ratio1 * lerp(0.5, 2.0, layerState.voice.ratio1);
            const finalRatio2 = params.ratio2 * lerp(0.5, 2.0, layerState.voice.ratio2);
            const finalModIndex = params.modIndex * lerp(0.3, 3.0, layerState.voice.fmIndex);
            
            engine.fmSynth.harmonicity.value = finalRatio1;
            engine.fmSynth.modulationIndex.value = finalModIndex;
            engine.fmSynth.envelope.attack = params.envAttack;
            engine.fmSynth.envelope.decay = params.envDecay;
            engine.fmSynth.envelope.sustain = params.envSustain;
            engine.fmSynth.envelope.release = params.envRelease;
            
            engine.fmSynth2.harmonicity.value = finalRatio2;
            engine.fmSynth2.modulationIndex.value = finalModIndex * 0.7;
            engine.fmSynth2.envelope.attack = params.envAttack;
            engine.fmSynth2.envelope.decay = params.envDecay * 0.8;
            engine.fmSynth2.envelope.sustain = params.envSustain;
            engine.fmSynth2.envelope.release = params.envRelease;
            
            engine.filter.frequency.value = params.filterCutoff;
            engine.filter.Q.value = params.filterQ;
            
            engine.airFilter.frequency.value = params.airCutoff;
            
            const finalDrive = params.driveAmount * lerp(0.1, 1.5, layerState.voice.drive);
            engine.distortion.distortion = clamp(finalDrive * 0.4, 0, 0.98);
            engine.distortion.wet.value = clamp(finalDrive * 0.5, 0, 1);
            
            engine.reverb.wet.value = layerState.fx.reverb * (1 + currentMacros.melodicize * 0.8);
            engine.delay.wet.value = layerState.fx.delayMix;
            
            const duration = params.envDecay * 3;
            const noteName = Tone.Frequency(freq, "hz").toNote();
            
            const synthVel = vel * params.carrierGain;
            
            engine.fmSynth.triggerAttackRelease(noteName, duration, time, synthVel);
            
            if (currentMacros.shape > 0.3) {
                engine.fmSynth2.triggerAttackRelease(noteName, duration * 0.8, time, synthVel * 0.5);
            }
            
            if (params.noiseMix > 0.1) {
                engine.noiseEnv.triggerAttackRelease(
                    params.envDecay * 0.4,
                    time,
                    vel * params.noiseMix * params.transientGain
                );
            }
            
            if (params.airMix > 0.1) {
                engine.airEnv.triggerAttackRelease(
                    params.envDecay * 0.5,
                    time,
                    vel * params.airMix * 0.6
                );
            }
        }

        // ============================================================================
        // SCENE SYSTEM
        // ============================================================================
        
        function saveCurrentScene(layer) {
            return {
                macros: {...layer.macros},
                voice: {...layer.voice},
                pattern: layer.pattern.map(s => ({...s})),
                fx: {...layer.fx}
            };
        }

        function loadScene(layer, sceneData) {
            layer.macros = {...sceneData.macros};
            layer.voice = {...sceneData.voice};
            layer.pattern = sceneData.pattern.map(s => ({...s}));
            layer.fx = {...sceneData.fx};
        }

        function getCurrentMacros(layer) {
            const morph = layer.morphAmount;
            
            if (morph === 0 || !layer.scenes.A || !layer.scenes.B) {
                return layer.macros;
            }
            
            const sceneA = layer.scenes.A;
            const sceneB = layer.scenes.B;
            const morphed = {};
            
            for (const key in layer.macros) {
                morphed[key] = lerp(sceneA.macros[key], sceneB.macros[key], morph);
            }
            
            return morphed;
        }

        // ============================================================================
        // UI UPDATES
        // ============================================================================
        
        function updateUI() {
            const layer = getCurrentLayer();
            
            // Update sequencer
            document.querySelectorAll('.step').forEach((el, i) => {
                if (i >= layer.length) {
                    el.parentElement.style.display = 'none';
                    return;
                }
                el.parentElement.style.display = 'flex';
                el.classList.toggle('active', layer.pattern[i].t === 1);
                el.classList.toggle('current', i === layer.currentStep && globalState.playing);
                el.classList.toggle('accent', layer.pattern[i].acc === 1);
                
                const note = layer.pattern[i].note;
                if (layer.pattern[i].t) {
                    const scaleNotes = scales[globalState.scale];
                    const degree = Math.abs(note) % scaleNotes.length;
                    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const semitone = scaleNotes[degree];
                    const rootIdx = noteNames.indexOf(globalState.root);
                    const noteIdx = (rootIdx + semitone) % 12;
                    el.textContent = noteNames[noteIdx];
                } else {
                    el.textContent = '';
                }
            });
            
            // Update note sliders
            document.querySelectorAll('.note-slider').forEach((slider, i) => {
                if (i >= layer.length) return;
                slider.value = layer.pattern[i].note;
                
                const label = slider.nextElementSibling;
                if (label) {
                    label.textContent = layer.pattern[i].note > 0 ? `+${layer.pattern[i].note}` : layer.pattern[i].note;
                }
            });
            
            // Update knobs
            document.querySelectorAll('.knob').forEach(knob => {
                const macro = knob.dataset.macro;
                if (!macro || !layer.macros.hasOwnProperty(macro)) return;
                
                const value = layer.macros[macro];
                const rotation = -140 + (value * 280);
                knob.style.transform = `rotate(${rotation}deg)`;
                
                const valueEl = knob.nextElementSibling;
                if (valueEl && valueEl.classList.contains('knob-value')) {
                    valueEl.textContent = value.toFixed(2);
                }
            });
        }

        function updateAllControls() {
            const layer = getCurrentLayer();
            
            document.getElementById('tempoInput').value = globalState.tempo;
            document.getElementById('lengthSelect').value = layer.length;
            document.getElementById('clockDivSelect').value = layer.clockDivision;
            document.getElementById('rootSelect').value = globalState.root;
            document.getElementById('scaleSelect').value = globalState.scale;
            document.getElementById('octaveSelect').value = layer.octaveRange;
            
            // Update mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === layer.mode);
            });
            
            updateSlider('driveSlider', 'driveFill', layer.voice.drive * 100);
            updateSlider('tuneSlider', 'tuneFill', layer.voice.tune * 100);
            updateSlider('attackSlider', 'attackFill', layer.voice.attack * 100);
            updateSlider('ratio1Slider', 'ratio1Fill', layer.voice.ratio1 * 100);
            updateSlider('ratio2Slider', 'ratio2Fill', layer.voice.ratio2 * 100);
            updateSlider('fmIndexSlider', 'fmIndexFill', layer.voice.fmIndex * 100);
            
            updateSlider('delayMixSlider', 'delayMixFill', layer.fx.delayMix * 100);
            updateSlider('delayTimeSlider', 'delayTimeFill', layer.fx.delayTime * 100);
            updateSlider('delayFbSlider', 'delayFbFill', layer.fx.delayFb * 100);
            updateSlider('reverbSlider', 'reverbFill', layer.fx.reverb * 100);
            
            updateSlider('morphSlider', 'morphFill', layer.morphAmount * 100);
        }

        function updateSlider(sliderId, fillId, value) {
            document.getElementById(sliderId).value = value;
            document.getElementById(fillId).style.width = value + '%';
        }

        // ============================================================================
        // GRID INITIALIZATION
        // ============================================================================
        
        function initMacrosGrid() {
            const grid = document.getElementById('macrosGrid');
            grid.innerHTML = '';
            
            macroDefinitions.forEach(macro => {
                const container = document.createElement('div');
                container.className = 'macro-control';
                
                const label = document.createElement('label');
                label.className = 'macro-label';
                label.textContent = macro.label;
                
                const knobContainer = document.createElement('div');
                knobContainer.className = 'knob-container';
                
                const knob = document.createElement('div');
                knob.className = 'knob';
                knob.dataset.macro = macro.key;
                
                const value = document.createElement('span');
                value.className = 'knob-value';
                value.textContent = macro.default.toFixed(2);
                
                knobContainer.appendChild(knob);
                knobContainer.appendChild(value);
                container.appendChild(label);
                container.appendChild(knobContainer);
                grid.appendChild(container);
            });
        }

        function initSequencerGrid() {
            const grid = document.getElementById('sequencerGrid');
            grid.innerHTML = '';
            
            for (let i = 0; i < 16; i++) {
                const container = document.createElement('div');
                container.className = 'step-container';
                
                const step = document.createElement('div');
                step.className = 'step';
                step.dataset.index = i;
                
                // Better touch handling for mobile
                let touchStartTime = 0;
                let touchMoved = false;
                
                step.addEventListener('touchstart', (e) => {
                    touchStartTime = Date.now();
                    touchMoved = false;
                    e.preventDefault();
                }, { passive: false });
                
                step.addEventListener('touchmove', (e) => {
                    touchMoved = true;
                }, { passive: false });
                
                step.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    if (touchMoved) return;
                    
                    const touchDuration = Date.now() - touchStartTime;
                    const layer = getCurrentLayer();
                    
                    if (touchDuration > 400) {
                        // Long press - toggle accent
                        layer.pattern[i].acc = 1 - layer.pattern[i].acc;
                        navigator.vibrate && navigator.vibrate(50);
                    } else {
                        // Short press - toggle step
                        layer.pattern[i].t = 1 - layer.pattern[i].t;
                    }
                    
                    updateUI();
                }, { passive: false });
                
                // Desktop click handler
                step.onclick = (e) => {
                    // Ignore if this was triggered by touch
                    if (e.detail === 0) return;
                    
                    const layer = getCurrentLayer();
                    if (e.shiftKey) {
                        layer.pattern[i].acc = 1 - layer.pattern[i].acc;
                    } else {
                        layer.pattern[i].t = 1 - layer.pattern[i].t;
                    }
                    updateUI();
                };
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.className = 'note-slider';
                slider.min = '-7';
                slider.max = '7';
                slider.value = '0';
                slider.oninput = function() {
                    const layer = getCurrentLayer();
                    layer.pattern[i].note = parseInt(this.value);
                    updateUI();
                };
                
                const label = document.createElement('div');
                label.className = 'note-label';
                label.textContent = '0';
                
                container.appendChild(step);
                container.appendChild(slider);
                container.appendChild(label);
                grid.appendChild(container);
            }
        }

        function initModeSelector() {
            const selector = document.getElementById('modeSelector');
            const modes = ['drum', 'bass', 'lead', 'pad'];
            
            modes.forEach(mode => {
                const btn = document.createElement('button');
                btn.className = 'btn mode-btn';
                btn.dataset.mode = mode;
                btn.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
                btn.onclick = () => {
                    const layer = getCurrentLayer();
                    layer.mode = mode;
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    
                    const modePresets = {
                        drum: { shape: 0.25, melodicize: 0.05, decay: 0.3 },
                        bass: { shape: 0.45, melodicize: 0.2, decay: 0.4 },
                        lead: { shape: 0.65, melodicize: 0.5, decay: 0.5 },
                        pad: { shape: 0.85, melodicize: 0.7, decay: 0.7 }
                    };
                    
                    const preset = modePresets[mode];
                    for (const key in preset) {
                        layer.macros[key] = preset[key];
                    }
                    
                    updateUI();
                };
                selector.appendChild(btn);
            });
        }

        // ============================================================================
        // KNOB INTERACTION
        // ============================================================================
        
        let activeKnob = null;
        let activeKnobElement = null;
        let knobStartY = 0;
        let knobStartValue = 0;

        function initKnobs() {
            document.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('knob')) {
                    const macro = e.target.dataset.macro;
                    const layer = getCurrentLayer();
                    activeKnob = macro;
                    activeKnobElement = e.target;
                    knobStartY = e.clientY;
                    knobStartValue = layer.macros[macro];
                    e.preventDefault();
                    document.body.style.cursor = 'ns-resize';
                    e.target.style.borderColor = 'rgba(109, 217, 219, 0.9)';
                }
            });
            
            document.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('knob')) {
                    const macro = e.target.dataset.macro;
                    const layer = getCurrentLayer();
                    activeKnob = macro;
                    activeKnobElement = e.target;
                    knobStartY = e.touches[0].clientY;
                    knobStartValue = layer.macros[macro];
                    e.preventDefault();
                    e.target.style.borderColor = 'rgba(109, 217, 219, 0.9)';
                }
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!activeKnob) return;
                
                const delta = (knobStartY - e.clientY) / 150;
                const newValue = clamp(knobStartValue + delta, 0, 1);
                const layer = getCurrentLayer();
                layer.macros[activeKnob] = newValue;
                
                updateUI();
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!activeKnob) return;
                
                const delta = (knobStartY - e.touches[0].clientY) / 150;
                const newValue = clamp(knobStartValue + delta, 0, 1);
                const layer = getCurrentLayer();
                layer.macros[activeKnob] = newValue;
                
                updateUI();
                e.preventDefault();
            });
            
            document.addEventListener('mouseup', () => {
                if (activeKnob) {
                    if (activeKnobElement) {
                        activeKnobElement.style.borderColor = '';
                    }
                    activeKnob = null;
                    activeKnobElement = null;
                    document.body.style.cursor = 'default';
                }
            });
            
            document.addEventListener('touchend', () => {
                if (activeKnob) {
                    if (activeKnobElement) {
                        activeKnobElement.style.borderColor = '';
                    }
                    activeKnob = null;
                    activeKnobElement = null;
                }
            });
        }

        // ============================================================================
        // LAYER SWITCHING
        // ============================================================================
        
        document.querySelectorAll('.layer-tab').forEach(tab => {
            tab.onclick = () => {
                const layerIndex = parseInt(tab.dataset.layer);
                globalState.currentLayer = layerIndex;
                
                document.querySelectorAll('.layer-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                updateAllControls();
                updateUI();
            };
        });

        // ============================================================================
        // TRANSPORT CONTROLS
        // ============================================================================
        
        document.getElementById('playBtn').onclick = async function() {
            await initAudio();
            
            if (globalState.playing) {
                Tone.Transport.stop();
                loops.forEach(loop => loop.stop());
                globalState.playing = false;
                this.classList.remove('playing');
                this.textContent = '▶';
                // Reset all layer steps
                globalState.layers.forEach(layer => {
                    layer.currentStep = 0;
                });
            } else {
                // Reset all layer steps
                globalState.layers.forEach(layer => {
                    layer.currentStep = 0;
                });
                Tone.Transport.position = 0;
                loops.forEach(loop => loop.start(0));
                Tone.Transport.start();
                globalState.playing = true;
                this.classList.add('playing');
                this.textContent = '⏸';
            }
            updateUI();
        };

        // ============================================================================
        // PARAMETER CONTROLS
        // ============================================================================
        
        document.getElementById('tempoInput').oninput = function() {
            globalState.tempo = parseInt(this.value);
            if (initialized) {
                Tone.Transport.bpm.value = globalState.tempo;
            }
        };

        document.getElementById('lengthSelect').onchange = function() {
            const layer = getCurrentLayer();
            const layerIndex = globalState.currentLayer;
            const wasPlaying = globalState.playing;
            
            layer.length = parseInt(this.value);
            layer.currentStep = 0;
            
            // If playing, restart all loops to keep everything in sync
            if (wasPlaying && initialized) {
                // Stop transport
                Tone.Transport.stop();
                loops.forEach(loop => loop.stop());
                
                // Update the changed layer's interval
                loops[layerIndex].interval = getLoopInterval(layer.clockDivision, layer.length);
                
                // Reset all positions
                globalState.layers.forEach(l => l.currentStep = 0);
                Tone.Transport.position = 0;
                
                // Restart all loops together
                loops.forEach(loop => loop.start(0));
                Tone.Transport.start();
            }
            
            updateUI();
        };

        document.getElementById('clockDivSelect').onchange = function() {
            const layer = getCurrentLayer();
            const layerIndex = globalState.currentLayer;
            const wasPlaying = globalState.playing;
            
            layer.clockDivision = this.value;
            
            // If playing, restart all loops to keep everything in sync
            if (wasPlaying && initialized) {
                // Stop transport
                Tone.Transport.stop();
                loops.forEach(loop => loop.stop());
                
                // Update the changed layer's interval
                loops[layerIndex].interval = getLoopInterval(layer.clockDivision, layer.length);
                
                // Reset all positions
                globalState.layers.forEach(l => l.currentStep = 0);
                Tone.Transport.position = 0;
                
                // Restart all loops together
                loops.forEach(loop => loop.start(0));
                Tone.Transport.start();
                
                updateUI();
            }
        };

        document.getElementById('rootSelect').onchange = function() {
            globalState.root = this.value;
            updateUI();
        };

        document.getElementById('scaleSelect').onchange = function() {
            globalState.scale = this.value;
            updateUI();
        };

        document.getElementById('octaveSelect').onchange = function() {
            const layer = getCurrentLayer();
            layer.octaveRange = parseInt(this.value);
        };

        document.getElementById('randomBtn').onclick = () => {
            const layer = getCurrentLayer();
            
            macroDefinitions.forEach(macro => {
                layer.macros[macro.key] = Math.random();
            });
            
            layer.pattern.forEach((step, i) => {
                const isDownbeat = i % 4 === 0;
                step.t = isDownbeat ? 1 : (Math.random() < 0.35 ? 1 : 0);
                step.acc = Math.random() < 0.15 ? 1 : 0;
                step.note = Math.floor(Math.random() * 15) - 7;
            });
            
            updateUI();
        };

        document.getElementById('evolveBtn').onclick = () => {
            const layer = getCurrentLayer();
            
            for (const key in layer.macros) {
                const current = layer.macros[key];
                const mutation = gauss(0, 0.08);
                layer.macros[key] = clamp(current + mutation, 0, 1);
            }
            
            const mutateSteps = Math.floor(Math.random() * 3) + 1;
            for (let i = 0; i < mutateSteps; i++) {
                const idx = Math.floor(Math.random() * layer.length);
                if (Math.random() < 0.5) {
                    layer.pattern[idx].t = 1 - layer.pattern[idx].t;
                } else if (Math.random() < 0.5) {
                    layer.pattern[idx].acc = 1 - layer.pattern[idx].acc;
                } else {
                    layer.pattern[idx].note = clamp(layer.pattern[idx].note + (Math.random() > 0.5 ? 1 : -1) * Math.floor(Math.random() * 3), -7, 7);
                }
            }
            
            updateUI();
        };

        // ============================================================================
        // VOICE SLIDERS
        // ============================================================================
        
        document.getElementById('driveSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.voice.drive = this.value / 100;
            document.getElementById('driveFill').style.width = this.value + '%';
        };

        document.getElementById('tuneSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.voice.tune = this.value / 100;
            document.getElementById('tuneFill').style.width = this.value + '%';
        };

        document.getElementById('attackSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.voice.attack = this.value / 100;
            document.getElementById('attackFill').style.width = this.value + '%';
        };

        document.getElementById('ratio1Slider').oninput = function() {
            const layer = getCurrentLayer();
            layer.voice.ratio1 = this.value / 100;
            document.getElementById('ratio1Fill').style.width = this.value + '%';
        };

        document.getElementById('ratio2Slider').oninput = function() {
            const layer = getCurrentLayer();
            layer.voice.ratio2 = this.value / 100;
            document.getElementById('ratio2Fill').style.width = this.value + '%';
        };

        document.getElementById('fmIndexSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.voice.fmIndex = this.value / 100;
            document.getElementById('fmIndexFill').style.width = this.value + '%';
        };

        // ============================================================================
        // FX SLIDERS
        // ============================================================================
        
        document.getElementById('delayMixSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.fx.delayMix = this.value / 100;
            document.getElementById('delayMixFill').style.width = this.value + '%';
            if (initialized && audioEngines[globalState.currentLayer]) {
                audioEngines[globalState.currentLayer].delay.wet.value = layer.fx.delayMix;
            }
        };

        document.getElementById('delayTimeSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.fx.delayTime = this.value / 100;
            document.getElementById('delayTimeFill').style.width = this.value + '%';
            if (initialized && audioEngines[globalState.currentLayer]) {
                const times = ['16n', '16n.', '8n', '8n.', '4n', '4n.', '2n'];
                const idx = Math.floor(layer.fx.delayTime * (times.length - 1));
                audioEngines[globalState.currentLayer].delay.delayTime.value = times[idx];
            }
        };

        document.getElementById('delayFbSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.fx.delayFb = this.value / 100;
            document.getElementById('delayFbFill').style.width = this.value + '%';
            if (initialized && audioEngines[globalState.currentLayer]) {
                audioEngines[globalState.currentLayer].delay.feedback.value = layer.fx.delayFb;
            }
        };

        document.getElementById('reverbSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.fx.reverb = this.value / 100;
            document.getElementById('reverbFill').style.width = this.value + '%';
            if (initialized && audioEngines[globalState.currentLayer]) {
                audioEngines[globalState.currentLayer].reverb.wet.value = layer.fx.reverb;
            }
        };

        // ============================================================================
        // SCENE CONTROLS
        // ============================================================================
        
        document.getElementById('sceneABtn').onclick = function() {
            const layer = getCurrentLayer();
            document.querySelectorAll('.scene-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            layer.currentScene = 'A';
            if (layer.scenes.A) {
                loadScene(layer, layer.scenes.A);
                updateAllControls();
                updateUI();
            }
        };

        document.getElementById('sceneBBtn').onclick = function() {
            const layer = getCurrentLayer();
            document.querySelectorAll('.scene-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            layer.currentScene = 'B';
            if (layer.scenes.B) {
                loadScene(layer, layer.scenes.B);
                updateAllControls();
                updateUI();
            }
        };

        document.getElementById('saveSceneBtn').onclick = function() {
            const layer = getCurrentLayer();
            layer.scenes[layer.currentScene] = saveCurrentScene(layer);
            console.log(`💾 Layer ${globalState.currentLayer + 1} Scene ${layer.currentScene} saved`);
        };

        document.getElementById('morphSlider').oninput = function() {
            const layer = getCurrentLayer();
            layer.morphAmount = this.value / 100;
            document.getElementById('morphFill').style.width = this.value + '%';
        };

        document.getElementById('testToneBtn').onclick = async function() {
            await initAudio();
            const engine = audioEngines[globalState.currentLayer];
            if (engine) {
                engine.fmSynth.triggerAttackRelease('C3', 0.5);
            }
        };

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        window.addEventListener('load', () => {
            console.log('🚀 Percaloid Engine v2 - 3 Layer System');
            initMacrosGrid();
            initSequencerGrid();
            initModeSelector();
            initKnobs();
            updateAllControls();
            updateUI();
        });
    </script>
</body>
</html>
